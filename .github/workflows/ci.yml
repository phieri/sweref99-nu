name: Build all

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
  pull_request:
    branches:
      - main
    paths-ignore:
      - '**.md'

jobs:
  build-sqlite:
    name: Build SQLite
    runs-on: ubuntu-latest
    steps:
      - name: Cache SQLite source
        id: cache-sqlite-source
        uses: actions/cache@v4
        with:
          path: sqlite-amalgamation-3420000.zip
          key: sqlite-3420000-source
      - name: Download SQLite source
        if: steps.cache-sqlite-source.outputs.cache-hit != 'true'
        run: |
          wget https://www.sqlite.org/2023/sqlite-amalgamation-3420000.zip
      - name: Cache SQLite build
        id: cache-sqlite-build
        uses: actions/cache@v4
        with:
          path: |
            sqlite-amalgamation-3420000/libsqlite3.a
            sqlite-amalgamation-3420000/sqlite3.h
          key: sqlite-3420000-build-${{ runner.os }}-emcc
      - name: Install build dependencies
        if: steps.cache-sqlite-build.outputs.cache-hit != 'true'
        run: |
          sudo apt-get -qq update && sudo apt-get --quiet --assume-yes install \
            emscripten build-essential
      - name: Build SQLite
        if: steps.cache-sqlite-build.outputs.cache-hit != 'true'
        run: |
          unzip sqlite-amalgamation-3420000.zip
          cd sqlite-amalgamation-3420000
          emcc -Os -c sqlite3.c -o sqlite3.o
          emar rcs libsqlite3.a sqlite3.o
      - uses: actions/upload-artifact@v4
        with:
          name: sqlite3
          path: |
            sqlite-amalgamation-3420000/libsqlite3.a
            sqlite-amalgamation-3420000/sqlite3.h
  build-proj:
    name: Build PROJ
    runs-on: ubuntu-latest
    needs: build-sqlite
    steps:
      - uses: actions/checkout@v5
        with:
          repository: OSGeo/PROJ
          ref: 9.6.2
      - uses: actions/download-artifact@v4
        with:
          name: sqlite3
          path: ./sqlite3/
      - name: Cache PROJ build
        id: cache-proj-build
        uses: actions/cache@v4
        with:
          path: |
            build/install/lib/libproj.a
            build/install/include
          key: proj-9.6.2-optimized-build-${{ runner.os }}-emcc-${{ hashFiles('sqlite3/libsqlite3.a') }}-v5
      - name: Install build dependencies
        if: steps.cache-proj-build.outputs.cache-hit != 'true'
        run: |
          sudo apt-get -qq update && sudo apt-get --quiet --assume-yes install \
            emscripten build-essential cmake python3
      - name: Create optimization script
        if: steps.cache-proj-build.outputs.cache-hit != 'true'
        run: |
          cat > optimize_proj_db.py << 'EOF'
          #!/usr/bin/env python3
          """
          Optimize proj.db by removing unwanted coordinate systems using a subtractive approach.
          This script uses hardcoded IDs for Swedish coordinate systems for performance.
          """
          
          import sqlite3
          import sys
          import os
          
          def get_swedish_coordinate_systems():
              """Define the coordinate systems needed for Swedish applications"""
              return {
                  # Hardcoded IDs based on dependency analysis to avoid runtime computation
                  # Note: 'conversion' is excluded as it's a view in PROJ databases, not a table
                  'geodetic_crs': ['4326', '4619'],
                  'projected_crs': ['3006'],
                  'geodetic_datum': ['6326', '6619'],
                  'ellipsoid': ['7030', '7019'],
                  'prime_meridian': ['8901'],
                  'unit_of_measure': ['9001', '9102'],
                  'celestial_body': ['PROJ:EARTH'],
                  'coordinate_system': ['6422', '4500'],
                  'extent': ['2830', '1225'],
                  'scope': ['1183', '1210'],
                  'usage': []  # Will be computed based on the above entries
              }
          
          def get_hardcoded_dependencies():
              """Return hardcoded dependencies instead of runtime analysis for performance"""
              return get_swedish_coordinate_systems()
          
          def optimize_proj_db(input_path, output_path=None):
              """Remove unwanted entries from proj.db keeping only Swedish coordinate systems"""
              if output_path is None:
                  output_path = input_path
              
              # Use hardcoded dependencies for performance
              print("Using hardcoded dependencies for Swedish coordinate systems...")
              needed_ids = get_hardcoded_dependencies()
              
              # Print what we're keeping
              total_kept = 0
              for table_name, ids in needed_ids.items():
                  if ids:
                      print(f"Keeping {len(ids)} entries in {table_name}: {ids[:5]}{'...' if len(ids) > 5 else ''}")
                      total_kept += len(ids)
              
              print(f"Total entries to keep: {total_kept}")
              
              # Get original size
              original_size = os.path.getsize(input_path)
              print(f"Original database size: {original_size:,} bytes")
              
              # Create optimized database
              conn = sqlite3.connect(input_path)
              
              # Get list of actual tables vs views
              cursor = conn.execute("SELECT name, type FROM sqlite_master WHERE type IN ('table', 'view')")
              db_objects = {name: obj_type for name, obj_type in cursor.fetchall()}
              
              print("\\nDatabase objects found:")
              for name, obj_type in sorted(db_objects.items()):
                  if name in needed_ids:
                      print(f"  {obj_type}: {name}")
              
              # Count original entries (only for tables and views that exist)
              original_counts = {}
              for table_name in needed_ids.keys():
                  if table_name in db_objects:
                      try:
                          cursor = conn.execute(f"SELECT COUNT(*) FROM {table_name}")
                          original_counts[table_name] = cursor.fetchone()[0]
                      except sqlite3.Error as e:
                          print(f"Warning: Could not count {table_name}: {e}")
                          original_counts[table_name] = 0
              
              # Remove unwanted entries (only from tables, not views)
              removed_counts = {}
              for table_name, keep_ids in needed_ids.items():
                  if not keep_ids:
                      continue
                      
                  # Skip if not in database or is a view
                  if table_name not in db_objects:
                      print(f"Skipping {table_name}: not found in database")
                      continue
                      
                  if db_objects[table_name] == 'view':
                      print(f"Skipping {table_name}: is a view, cannot modify")
                      continue
                  
                  try:
                      if table_name == 'celestial_body':
                          # Special handling for celestial_body (auth_name:code format)
                          auth_codes = []
                          for item in keep_ids:
                              if ':' in item:
                                  auth, code = item.split(':', 1)
                                  auth_codes.append((auth, code))
                          
                          if auth_codes:
                              placeholders = ','.join(['(?,?)'] * len(auth_codes))
                              flat_params = []
                              for auth, code in auth_codes:
                                  flat_params.extend([auth, code])
                              
                              cursor = conn.execute(f"SELECT COUNT(*) FROM {table_name}")
                              before_count = cursor.fetchone()[0]
                              
                              conn.execute(f"""
                                  DELETE FROM {table_name} 
                                  WHERE (auth_name, code) NOT IN (VALUES {placeholders})
                              """, flat_params)
                              
                              cursor = conn.execute(f"SELECT COUNT(*) FROM {table_name}")
                              after_count = cursor.fetchone()[0]
                              removed_counts[table_name] = before_count - after_count
                      else:
                          # Regular tables with EPSG auth_name
                          cursor = conn.execute(f"SELECT COUNT(*) FROM {table_name}")
                          before_count = cursor.fetchone()[0]
                          
                          if table_name == 'usage':
                              # For usage table, we need to keep entries that reference our objects
                              keep_usage_sql = """
                                  DELETE FROM usage WHERE NOT (
                                      (object_table_name='geodetic_crs' AND object_auth_name='EPSG' AND object_code IN ({}))
                                      OR (object_table_name='projected_crs' AND object_auth_name='EPSG' AND object_code IN ({}))
                                  )
                              """.format(
                                  ','.join('?' * len(needed_ids['geodetic_crs'])),
                                  ','.join('?' * len(needed_ids['projected_crs']))
                              )
                              params = needed_ids['geodetic_crs'] + needed_ids['projected_crs']
                              conn.execute(keep_usage_sql, params)
                          else:
                              placeholders = ','.join(['?'] * len(keep_ids))
                              # Delete ALL entries except our specific EPSG ones
                              conn.execute(f"""
                                  DELETE FROM {table_name} 
                                  WHERE NOT (auth_name='EPSG' AND code IN ({placeholders}))
                              """, keep_ids)
                          
                          cursor = conn.execute(f"SELECT COUNT(*) FROM {table_name}")
                          after_count = cursor.fetchone()[0]
                          removed_counts[table_name] = before_count - after_count
                          
                  except sqlite3.Error as e:
                      print(f"Error processing {table_name}: {e}")
                      removed_counts[table_name] = 0
              
              # Also handle metadata table - keep it as is
              if 'metadata' in db_objects:
                  cursor = conn.execute("SELECT COUNT(*) FROM metadata")
                  metadata_count = cursor.fetchone()[0]
                  print(f"Keeping all {metadata_count} metadata entries")
              else:
                  print("No metadata table found")
              
              conn.commit()
              
              # Vacuum the database to reclaim space from deleted entries
              print("Vacuuming database to reclaim space...")
              conn.execute("VACUUM")
              conn.close()
              
              # Report results
              optimized_size = os.path.getsize(input_path)
              print(f"\nOptimization complete!")
              print(f"Optimized database size: {optimized_size:,} bytes")
              print(f"Size reduction: {original_size - optimized_size:,} bytes ({(1 - optimized_size/original_size)*100:.1f}%)")
              
              print(f"\nEntries removed by table:")
              total_removed = 0
              for table_name, removed_count in removed_counts.items():
                  if removed_count > 0:
                      original_count = original_counts.get(table_name, 0)
                      kept_count = original_count - removed_count
                      print(f"  {table_name}: {removed_count:,} removed, {kept_count} kept")
                      total_removed += removed_count
              
              print(f"Total entries removed: {total_removed:,}")
              
              return optimized_size
          
          if __name__ == '__main__':
              if len(sys.argv) < 2:
                  print("Usage: python3 optimize_proj_db.py <proj.db_path> [output_path]")
                  sys.exit(1)
              
              input_path = sys.argv[1]
              output_path = sys.argv[2] if len(sys.argv) > 2 else None
              
              if not os.path.exists(input_path):
                  print(f"Error: Database file not found: {input_path}")
                  sys.exit(1)
              
              optimize_proj_db(input_path, output_path)
          EOF
      - name: Build PROJ
        if: steps.cache-proj-build.outputs.cache-hit != 'true'
        run: |
          # Remove build directory if it exists from previous partial runs
          rm -rf build/proj_build
          mkdir -p build/proj_build
          cd build/proj_build
          emcmake cmake ../.. \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_C_FLAGS="-Os" \
            -DCMAKE_CXX_FLAGS="-Os" \
            -DBUILD_APPS=OFF \
            -DBUILD_TESTING=OFF \
            -DBUILD_SHARED_LIBS=OFF \
            -DSQLite3_INCLUDE_DIR=$(pwd)/../../sqlite3 \
            -DSQLite3_LIBRARY=$(pwd)/../../sqlite3/libsqlite3.a \
            -DENABLE_CURL=OFF \
            -DENABLE_TIFF=OFF \
            -DUSE_EXTERNAL_GTEST=OFF \
            -DBUILD_PROJSYNC=OFF \
            -DCMAKE_INSTALL_PREFIX=$(pwd)/../install
          emmake make -j$(nproc)
          emmake make install
      - name: Optimize PROJ database
        if: steps.cache-proj-build.outputs.cache-hit != 'true'
        run: |
          # Find the proj.db in the installed PROJ build
          PROJ_DB_PATH=$(find build/install -name "proj.db" | head -1)
          if [ -z "$PROJ_DB_PATH" ]; then
            echo "Error: proj.db not found in PROJ installation"
            find build/install -name "*.db" || echo "No .db files found"
            exit 1
          fi
          echo "Found proj.db at: $PROJ_DB_PATH"
          echo "Original size: $(ls -lh "$PROJ_DB_PATH" | awk '{print $5}')"
          
          # Optimize the database using subtractive approach
          python3 optimize_proj_db.py "$PROJ_DB_PATH"
          echo "Optimized size: $(ls -lh "$PROJ_DB_PATH" | awk '{print $5}')"
      - name: Stage artifacts
        run: |
          # Copy files to expected artifact structure
          mkdir -p artifact-staging
          cp build/install/lib/libproj.a artifact-staging/
          cp -r build/install/include artifact-staging/
          # Include SQLite3 library that PROJ depends on
          cp sqlite3/libsqlite3.a artifact-staging/
      - uses: actions/upload-artifact@v4
        with:
          name: proj
          path: artifact-staging/
  build-wasm:
    name: Build Wasm
    runs-on: ubuntu-24.04
    needs: build-proj
    steps:
      - uses: actions/checkout@v5
      - uses: actions/download-artifact@v4
        with:
          name: proj
          path: ./
      - name: Install build dependencies
        run: |
          sudo apt-get -qq update && sudo apt-get --quiet --assume-yes install \
            emscripten build-essential
      - run: |
          echo "=== Checking downloaded artifacts ==="
          ls -la
          echo "=== Creating build structure ==="
          # Create build directory and move artifacts to expected locations
          mkdir -p build/include
          # Move libproj.a to expected location
          if [ -f libproj.a ]; then
            mv libproj.a build/
            echo "Moved libproj.a to build/"
          else
            echo "ERROR: libproj.a not found"
            exit 1
          fi
          # Move libsqlite3.a to expected location
          if [ -f libsqlite3.a ]; then
            mv libsqlite3.a build/
            echo "Moved libsqlite3.a to build/"
          else
            echo "ERROR: libsqlite3.a not found"
            exit 1
          fi
          # Move headers to expected location
          if [ -d include ]; then
            mv include/* build/include/
            echo "Moved headers to build/include/"
          else
            echo "ERROR: include directory not found"
            exit 1
          fi
          echo "=== Final build structure ==="
          ls -la build/
          ls -la build/include/
          echo "=== Building WASM ==="
          make sr9.wasm
      - uses: actions/upload-artifact@v4
        with:
          name: wasm
          path: |
            sr9.wasm
            sr9.js
  build:
    name: Build
    runs-on: ubuntu-24.04
    needs: build-wasm
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Cache TypeScript
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-typescript-global
          restore-keys: |
            ${{ runner.os }}-typescript-
      - run: npm install -g typescript
      - uses: actions/download-artifact@v4
        with:
          name: wasm
          path: ./
      - run: |
          echo "=== Checking downloaded WASM artifacts ==="
          ls -la
          echo "=== Building TypeScript ==="
          make script.js
          echo "=== Copying WASM files to _site ==="
          cp sr9.wasm _site/
          cp sr9.js _site/
          echo "=== Final _site contents ==="
          ls -la _site/
          echo "=== Adding additional files ==="
          echo "${{ vars.adstxt }}" > _site/ads.txt
          curl -o _site/pico.min.css https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css
          echo "=== Final _site contents ==="
          ls -la _site/
      - uses: actions/upload-pages-artifact@v4
  deploy:
    name: Deploy
    needs: build
    if: github.ref == 'refs/heads/main'
    permissions:
      pages: write
      id-token: write
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
